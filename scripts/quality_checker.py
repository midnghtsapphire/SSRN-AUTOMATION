#!/usr/bin/env python3
"""
SSRN Paper Quality Checker
Validates paper format, content, and naming conventions
"""

import re
import sys
from datetime import datetime
from pathlib import Path


class PaperQualityChecker:
    """Validates SSRN papers for quality and compliance"""
    
    # Forbidden terms that indicate AI generation or automation
    FORBIDDEN_TERMS = [
        'manus', 'ai-generated', 'artificial intelligence generated',
        'automated', 'auto-generated', 'machine learning model',
        'language model', 'gpt', 'chatgpt', 'claude', 'generated by',
        'ai assistant', 'ai watermark', 'this paper was generated'
    ]
    
    # Required sections
    REQUIRED_SECTIONS = [
        'abstract', 'introduction', 'methodology', 'analysis',
        'conclusion', 'keywords', 'jel codes'
    ]
    
    def __init__(self, paper_path):
        self.paper_path = Path(paper_path)
        self.errors = []
        self.warnings = []
        
    def check_filename(self):
        """Validate filename follows Walter_Evans_[ShortTitle]_[YYYYMMDD].pdf format"""
        filename = self.paper_path.name
        
        # Must start with Walter_Evans_
        if not filename.startswith('Walter_Evans_'):
            self.errors.append(f"Filename must start with 'Walter_Evans_': {filename}")
            return False
            
        # Check pattern: Walter_Evans_[ShortTitle]_[YYYYMMDD].pdf
        pattern = r'^Walter_Evans_[A-Za-z_]+_\d{8}\.pdf$'
        if not re.match(pattern, filename):
            self.errors.append(
                f"Filename must follow format 'Walter_Evans_[ShortTitle]_[YYYYMMDD].pdf': {filename}"
            )
            return False
            
        # Validate date
        try:
            date_str = filename.split('_')[-1].replace('.pdf', '')
            datetime.strptime(date_str, '%Y%m%d')
        except ValueError:
            self.errors.append(f"Invalid date format in filename: {filename}")
            return False
            
        return True
    
    def check_content(self, text):
        """Validate paper content for forbidden terms and required sections"""
        text_lower = text.lower()
        
        # Check for forbidden AI/automation terms
        for term in self.FORBIDDEN_TERMS:
            if term.lower() in text_lower:
                self.errors.append(
                    f"Forbidden term detected (AI watermark): '{term}'"
                )
        
        # Check for required sections
        for section in self.REQUIRED_SECTIONS:
            if section.lower() not in text_lower:
                self.warnings.append(f"Missing or unclear section: {section}")
        
        # Check abstract length (should be ≤200 words)
        abstract_match = re.search(
            r'abstract\s*\n(.*?)\n(?:keywords|introduction)',
            text_lower,
            re.DOTALL | re.IGNORECASE
        )
        if abstract_match:
            abstract_text = abstract_match.group(1).strip()
            word_count = len(abstract_text.split())
            if word_count > 200:
                self.errors.append(
                    f"Abstract exceeds 200 words ({word_count} words)"
                )
        
        return len(self.errors) == 0
    
    def check_metadata(self, text):
        """Validate metadata is clean and professional"""
        text_lower = text.lower()
        
        # Check for author information
        if 'audrey evans' not in text_lower:
            self.errors.append("Author name 'Audrey Evans' not found")
        
        # Check for ORCID
        if '0009-0005-0663-7832' not in text:
            self.warnings.append("ORCID not found in paper")
        
        # Ensure no author name in body text (only in header/metadata)
        body_start = text_lower.find('introduction')
        if body_start > 0:
            body_text = text_lower[body_start:]
            if 'audrey evans' in body_text:
                self.errors.append(
                    "Author name found in body text (should only be in header)"
                )
        
        # Check for keywords
        if 'keywords:' not in text_lower:
            self.errors.append("Keywords section not found")
        
        # Check for JEL codes
        if 'jel codes:' not in text_lower and 'jel classification:' not in text_lower:
            self.errors.append("JEL codes section not found")
        
        return len(self.errors) == 0
    
    def check_human_voice(self, text):
        """Check for authentic human writing style"""
        text_lower = text.lower()
        
        # Patterns that suggest AI generation
        ai_patterns = [
            r'as an ai',
            r'i cannot',
            r'i don\'t have',
            r'as a language model',
            r'i apologize',
            r'it\'s important to note that',
            r'it is worth noting',
            r'in conclusion, it can be said'
        ]
        
        for pattern in ai_patterns:
            if re.search(pattern, text_lower):
                self.errors.append(
                    f"AI-style phrasing detected: '{pattern}'"
                )
        
        return len(self.errors) == 0
    
    def run_checks(self, text=None):
        """Run all quality checks"""
        print(f"\n{'='*60}")
        print(f"SSRN Paper Quality Check: {self.paper_path.name}")
        print(f"{'='*60}\n")
        
        # Check filename
        print("✓ Checking filename format...")
        self.check_filename()
        
        if text:
            # Check content
            print("✓ Checking content structure...")
            self.check_content(text)
            
            # Check metadata
            print("✓ Checking metadata...")
            self.check_metadata(text)
            
            # Check human voice
            print("✓ Checking writing style...")
            self.check_human_voice(text)
        
        # Report results
        print(f"\n{'='*60}")
        print("RESULTS")
        print(f"{'='*60}\n")
        
        if self.errors:
            print(f"❌ ERRORS ({len(self.errors)}):")
            for error in self.errors:
                print(f"   • {error}")
            print()
        
        if self.warnings:
            print(f"⚠️  WARNINGS ({len(self.warnings)}):")
            for warning in self.warnings:
                print(f"   • {warning}")
            print()
        
        if not self.errors and not self.warnings:
            print("✅ All checks passed! Paper is ready for submission.")
        elif not self.errors:
            print("✅ No critical errors. Review warnings before submission.")
        else:
            print("❌ Paper has errors. Please fix before submission.")
        
        print(f"\n{'='*60}\n")
        
        return len(self.errors) == 0


def main():
    if len(sys.argv) < 2:
        print("Usage: python quality_checker.py <paper_path> [text_file]")
        sys.exit(1)
    
    paper_path = sys.argv[1]
    text = None
    
    if len(sys.argv) > 2:
        with open(sys.argv[2], 'r', encoding='utf-8') as f:
            text = f.read()
    
    checker = PaperQualityChecker(paper_path)
    success = checker.run_checks(text)
    
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
